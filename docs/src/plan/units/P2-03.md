# P2-03: Integrate Memory into Runtime

## Goal

Make Runtime generic over Memory, inject memory at construction, register
a "remember" tool for explicit memory storage, and orchestrate memory
flush before compaction.

## Depends On

Phase 1 (P1-01, P1-02 — revised Memory trait, MemoryEntry, RecallOptions).

## Design Decisions

- Runtime becomes `Runtime<M: Memory = InMemory>`. Default type parameter
  preserves backward compatibility.
- Constructor: `Runtime::new(config, provider, memory)`. Memory required
  (use `InMemory::new()` when no persistence needed).
- System prompt enrichment: before each LLM call, call
  `memory.compile_relevant(last_user_message, 5)` and append to agent
  system prompt.
- "remember" tool: Runtime auto-registers a tool named `"remember"` with
  schema `{ key: string, value: string }`. Handler calls `memory.store()`.
  Available to any agent that lists `"remember"` in its tools.
- Memory flush before compaction (DD#7): when `needs_compaction()` is true,
  Runtime sends a silent LLM turn to extract key facts, then calls
  `memory.store()` for each fact, then runs the compactor.
- All existing tests pass using `Runtime<InMemory>` with no behavior change.

## Files

- **MODIFY** `crates/runtime/src/lib.rs` — add generic M param, memory field,
  update new(), send(), stream(), api_messages(), register "remember" tool

## Tests

- `runtime_with_inmemory` — verify construction with InMemory works
- `system_prompt_includes_memory` — verify compile_relevant output in messages
- `remember_tool_registered` — verify "remember" tool exists after construction
- `remember_tool_stores_value` — verify dispatching "remember" persists to memory
- `existing_tests_pass` — all existing tests unchanged (M defaults to InMemory)

## Done When

- [ ] `cargo check --workspace` and `cargo test --workspace` pass
- [ ] Runtime is generic over Memory
- [ ] Memory content injected into system prompts
- [ ] "remember" tool auto-registered and functional
