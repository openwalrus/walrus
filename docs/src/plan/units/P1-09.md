# P1-09: Implement SqliteMemory recall + compile_relevant

## Goal

Implement search methods: `recall()` with BM25 full-text search and temporal decay,
and `compile_relevant()` for prompt injection.

## Depends On

P1-08.

## Design Decisions

Retrieval pipeline (executed in order):

1. BM25 via FTS5 `MATCH` with `bm25()` ranking function.
2. Optional vector search via Embedder (cosine similarity). Deferred in this unit — BM25-only even if embedder is attached.
3. Weighted merge: `vector_weight * vector_score + text_weight * bm25_score`. BM25-only until vector search is added.
4. Temporal decay: `score * e^(-lambda * age_in_days)`, default half-life 30 days. Decay computed from `accessed_at`.
5. MMR re-ranking: `lambda * relevance - (1 - lambda) * max_similarity_to_selected`, lambda defaults to 0.7. Similarity via Jaccard over tokens.
6. Top-k truncation per RecallOptions.limit (defaults to 10 if 0).

Additional:
- time_range filters by created_at. relevance_threshold filters by post-decay score.
- compile_relevant calls recall with limit 5, formats as `<memory>` XML blocks.

## Files

- **MODIFY** `crates/sqlite/src/lib.rs` — implement recall() and compile_relevant()

## Tests (all use in_memory)

- `recall_empty_db`
- `recall_finds_relevant`
- `recall_respects_limit`
- `recall_time_range_filter`
- `compile_relevant_formats_xml`
- `compile_relevant_empty`

## Done When

- [ ] `cargo check --workspace` and `cargo test --workspace` pass
- [ ] FTS5 BM25 search returns relevant entries
- [ ] compile_relevant() produces valid XML blocks
- [ ] **Phase 1 complete**
